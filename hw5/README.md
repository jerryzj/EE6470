

# EE6470 HW5 Pooling Engine on SCML Platform

#### 107061517 張簡崇堯
## Execution
```shell
# Assume you are already in project root dir and you can see src dir and CMakeLists.txt
$ mkdir build && cd build
$ cmake ..
$ make
$./pooling
```
## Introduction

In this homework, I port the pooling layer in Lenet Neural Network to the SystemC SCML platform. The Lenet is generated by TVM and the SCML platform already has an pooling engine and corresponding DMA on it.
## Implementation

### Part I

For part 1, I modified the  `Testbench::Test_Thread` to adapt the Lenet C++ code like this.

```c++
void Testbench::Test_Thread() {
	BaremetalDNN_model_wraper();
}
```

Therefore, the `Testbench` will call the Lenet DNN model and do the computation.

The next thing is to replace the original C++ pooling function and use the SCML pooling engine instead.

In `Op.cpp` , we can see many function implementations inside.

I removed the computational codes in  `void pool2d(TVMValue stack_value, int arg_num)`, and added the SCML platform configurations code instead.

Therefore, the porting job is done.

### Part II

For part 2,  we. are asked to decompose the input data of pooling engine into 4 pieces.

After tracing the source code, I found that use channel to do the decomposition is the easiest way.

I noticed that the pooling layer has many channels. Instead of spliting the image into 4 pieces, I think spliting by channel must be easier since we don't need to calculate memory offset anymore. (which is very complex)

In `Op.cpp`

```c++
// Split input data by channel
for(unsigned int c = 0; c < 4; c++){
    ShapeTy decomposed = ShapeTy(1, data_shape.c/4, data_shape.h, data_shape.w);
    // Create a new Tensor with the decomposed input data size, note that we simply divide 		   channel by 4
    const auto Iidx = data_shape.Idx(c * data_shape.c/4, 0, 0);
    // Iidx will record the memory offset of data_ptr
    const auto Oidx = output_shape.Idx(c * output_shape.c/4, 0, 0);
    // Oidx will record the memory offset of output_ptr
    // Load Test Data from DRAM to GLOBAL BUFFER
    // Note that here we only transmit the data before offset
    testbench.LoadTestData(GLOBAL_BUFFER_ADDRESS, &data_ptr[Iidx], test_data_num);
    // Configure DMA to load test data into Pooling Engine 
    // Ignore DMA config code...
    testbench.ConfigPoolDMA(dma_config);
    // Configure pooling engine to process test data 
    testbench.ConfigPoolEngine(pool_config);
    // Configure DMA to move results from buffer into RAM 
    // Ignore DMA config code...
    testbench.ConfigPoolDMA(dma_config);
    //Get result from RAM through debug transport (no timing effort)
    testbench.GetResult(GLOBAL_BUFFER_ADDRESS, &output_ptr[Oidx], result_num);
  }
```

## Results

Part I

![img1](https://github.com/jerryzj/EE6470/raw/master/assets/螢幕快照 2018-11-01 11.35.14.png)

Part II

![img2](/assets/螢幕快照 2018-11-01 11.36.04.png)

## Conclusion & Discussion

This homework needs to trace the source code for a very long time, but it's not that hard if you understand the code structure and the meaning of function calls.

Since I didn't implment pipelining execution, The simulation time will be loger after spliting the input data into 4 pieces.
